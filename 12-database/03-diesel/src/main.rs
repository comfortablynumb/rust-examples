// Diesel ORM Example
// Note: In a real project, you would use diesel_cli to generate migrations and schema

use diesel::prelude::*;
use diesel::r2d2::{self, ConnectionManager};
use diesel::sqlite::SqliteConnection;

type DbPool = r2d2::Pool<ConnectionManager<SqliteConnection>>;

// In a real app, this would be in schema.rs (generated by diesel_cli)
table! {
    posts (id) {
        id -> Integer,
        title -> Text,
        body -> Text,
        published -> Bool,
    }
}

#[derive(Queryable, Selectable, Debug)]
#[diesel(table_name = posts)]
struct Post {
    pub id: i32,
    pub title: String,
    pub body: String,
    pub published: bool,
}

#[derive(Insertable)]
#[diesel(table_name = posts)]
struct NewPost<'a> {
    pub title: &'a str,
    pub body: &'a str,
}

fn main() {
    println!("Diesel ORM Example");
    println!("==================");

    // Create connection pool
    let database_url = ":memory:";
    let manager = ConnectionManager::<SqliteConnection>::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect("Failed to create pool");

    let mut conn = pool.get().expect("Failed to get connection");

    // Create table (in real app, use migrations)
    diesel::sql_query(
        "CREATE TABLE posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            body TEXT NOT NULL,
            published BOOLEAN NOT NULL DEFAULT 0
        )"
    )
    .execute(&mut conn)
    .expect("Failed to create table");

    // Insert posts
    create_post(&mut conn, "First Post", "This is the first post body");
    create_post(&mut conn, "Second Post", "This is the second post body");
    create_post(&mut conn, "Third Post", "This is the third post body");

    // Query all posts
    println!("\nAll posts:");
    let results = posts::table
        .load::<Post>(&mut conn)
        .expect("Error loading posts");

    for post in results {
        println!("  {} - {} (published: {})", post.id, post.title, post.published);
    }

    // Query published posts
    println!("\nPublished posts:");
    let published_posts = posts::table
        .filter(posts::published.eq(true))
        .load::<Post>(&mut conn)
        .expect("Error loading posts");

    println!("  Count: {}", published_posts.len());

    // Update a post
    diesel::update(posts::table.find(1))
        .set(posts::published.eq(true))
        .execute(&mut conn)
        .expect("Failed to update");

    println!("\nPublished post with id=1");

    // Delete a post
    diesel::delete(posts::table.find(3))
        .execute(&mut conn)
        .expect("Failed to delete");

    println!("Deleted post with id=3");

    // Count remaining posts
    let count: i64 = posts::table
        .count()
        .get_result(&mut conn)
        .expect("Error counting");

    println!("\nRemaining posts: {}", count);
}

fn create_post(conn: &mut SqliteConnection, title: &str, body: &str) {
    let new_post = NewPost { title, body };

    diesel::insert_into(posts::table)
        .values(&new_post)
        .execute(conn)
        .expect("Error inserting post");
}
